# NEXT_DB_OPTIM（MySQL）数据库“升级/优化”可选项清单

适用场景：课程设计（数据量小、无明显性能痛点），目标是把系统做得更“像真实项目”，并且能在答辩/验收时**可演示、可解释、可量化**。

> 建议优先做：`索引 + EXPLAIN`、`事务与并发控制`、`约束/权限/审计`、`备份恢复演练`。  
> 进阶可选：`分区`、`主从复制读写分离`、`伪分片方案`、`分析报表模型`。

---

## 1. 快速路线（推荐你们挑 6–10 个点做）

**基础必做（展示专业性）**
1. 关键表补齐约束：`PK/UK/FK/CHECK`，字段类型与默认值规范化
2. 关键查询补复合索引，用 `EXPLAIN ANALYZE` 对比优化前后
3. 事务边界清晰：下单/取车/还车/取消/赔付等流程的原子性
4. 并发一致性：避免“重复租车/库存被抢占”（悲观锁或乐观锁）
5. 权限分级：`admin/manager/clerk/readonly` 角色最小权限
6. 审计与历史：订单状态变更流水表（可用触发器或应用侧写入）

**扩展加分（覆盖更多能力）**
7. 分区表：订单按月份 RANGE 分区（便于归档与查询）
8. 主从复制：演示只读副本、读写分离思路、延迟与容灾
9. 报表/分析：按门店/车型/月统计营收、利用率、周转天数
10. 备份恢复：`mysqldump` 备份 + 恢复演示（RPO/RTO 解释）

---

## 2. 广度升级（横向：更多能力覆盖）

### 2.1 主从复制 + 读写分离（课程最常见加分项）
**你能展示什么**
- 主库写、从库读（只读账户），解释“扩展读吞吐、降低主库压力”
- 故障切换思路（不必真做到自动切换，也能讲清流程）

**最小实现建议**
- 两个 MySQL 实例：`primary` 与 `replica`
- `replica` 设为只读：`read_only=ON`（或应用层限制）

**答辩要点**
- 复制延迟：为什么会出现、如何监控
- 一致性：强一致读 vs 最终一致读如何取舍

### 2.2 分区表（Partitioning）
适合“订单/流水”这种随时间增长的表。

**示例（按月份 RANGE 分区）**
```sql
-- 注意：示例字段名按你们实际表改
ALTER TABLE rental_order
PARTITION BY RANGE COLUMNS(created_at) (
  PARTITION p2025_01 VALUES LESS THAN ('2025-02-01'),
  PARTITION p2025_02 VALUES LESS THAN ('2025-03-01'),
  PARTITION pmax VALUES LESS THAN (MAXVALUE)
);
```

**答辩要点**
- 为什么分区能减少扫描范围（分区裁剪）
- 分区与索引的关系、分区维护（新增分区、归档旧分区）

### 2.3 “伪分片”演示（不引入中间件也能讲清）
数据量小不需要真分片，但可以演示“按门店/用户取模拆表”的思想。

**最小实现方式**
- 把 `rental_order` 拆成 `rental_order_0`、`rental_order_1`
- 写入时按 `user_id % 2` 或 `store_id % 2` 选择表
- 查询时用 `UNION ALL` + 统一视图（或应用层聚合）

**答辩要点**
- 分片键选择（避免跨分片查询、避免热点）
- 跨分片聚合/排序成本（为什么会变复杂）

### 2.4 报表/分析能力（OLTP 上做轻量分析）
给课程项目增加“经营分析”很加分。

**可展示的指标**
- 月营收、日订单量、门店周转（平均租期/空闲时长）
- 车型利用率（在租天数 / 总天数）

**实现建议**
- 保持 OLTP 表清晰，同时做 1–2 张“报表汇总表”（可日/周刷新）
- 用视图或存储过程输出报表

---

## 3. 深度升级（纵向：把 MySQL 用得更专业）

### 3.1 表结构与约束（数据质量）
**建议清单**
- 主键：整型自增或 UUID（二选一，统一全库风格）
- 唯一约束：例如 `plate_no`（车牌）、`user_phone`（手机号）等
- 外键：订单引用用户/车辆/门店（课程项目可开外键以展示完整性）
- CHECK：金额非负、状态枚举范围、日期先后关系

**示例**
```sql
ALTER TABLE car
  ADD CONSTRAINT uk_car_plate UNIQUE (plate_no);

ALTER TABLE rental_order
  ADD CONSTRAINT fk_order_user FOREIGN KEY (user_id) REFERENCES user(id),
  ADD CONSTRAINT fk_order_car  FOREIGN KEY (car_id)  REFERENCES car(id);
```

### 3.2 索引设计 + 慢查询治理（最好演示）
**常见高频查询（租车系统）**
- “门店可租车辆列表”：`store_id + status + price/day`
- “用户历史订单”：`user_id + created_at`
- “某辆车的当前状态/最近订单”：`car_id + status/created_at`

**索引建议（按你们实际 SQL 调整）**
- `rental_order (user_id, created_at)`
- `rental_order (car_id, status, created_at)`
- `car (store_id, status)` 或 `car (store_id, status, model_id)`

**演示方法**
- 准备 2 条“优化前慢、优化后快”的 SQL
- 用 `EXPLAIN ANALYZE` 展示扫描行数/执行时间变化

### 3.3 事务与并发一致性（避免重复租车/状态错乱）
典型问题：两个人同时对同一辆车下单，出现“双租”。

**方案 A：悲观锁（推荐课程演示）**
1. `START TRANSACTION`
2. `SELECT ... FOR UPDATE` 锁住目标车辆行
3. 校验车辆状态为可租
4. 写订单、更新车辆状态
5. `COMMIT`

**方案 B：乐观锁（更像互联网系统）**
- `car` 表加 `version` 字段
- 更新时带条件：`WHERE id=? AND version=?`，更新成功才算抢到

**答辩要点**
- 隔离级别（MySQL InnoDB 默认 `REPEATABLE READ`）会带来什么影响
- 为什么要控制事务范围，避免长事务

### 3.4 审计与历史（可追溯）
**最低成本做法（不一定要触发器）**
- 增加 `order_status_log`（订单状态流水表）
- 每次状态变更都写一条：谁改的、何时改的、从什么到什么、备注

可选：用触发器自动写审计（演示点更强，但要注意触发器维护成本）。

### 3.5 权限与安全（最小权限）
**角色建议**
- `db_admin`：DDL、全表管理（仅开发/维护）
- `store_manager`：本门店业务表 CRUD（可用视图/应用层限制门店范围）
- `clerk`：下单/还车等必要权限
- `readonly`：仅查询（用于报表/展示）

**能演示什么**
- 只读账号无法写入
- 业务账号只能访问必要表

### 3.6 备份恢复与演练（稳定性）
**你能展示什么**
- 逻辑备份：`mysqldump` 导出 SQL
- 恢复：导入到新库/新实例
- 解释 RPO/RTO：多久丢数据、多久恢复

**课程演示建议**
- 做一次“误删订单表数据”的模拟
- 用备份恢复并对比恢复前后

---

## 4. 可直接写进报告的“验收项/演示脚本”（建议选 5–8 个）

1. 用 `EXPLAIN ANALYZE` 展示 2 条 SQL 的优化前后对比（截图/数据）
2. 演示事务一致性：并发下同一辆车只会被成功下单一次（录屏或日志）
3. 展示约束：插入重复车牌失败、插入不存在用户的订单失败
4. 展示权限：只读用户无法 `INSERT/UPDATE`
5. 展示审计：订单从 `CREATED->PAID->PICKED->RETURNED` 的流水记录
6. 展示分区：按月份查询只扫描目标分区（`EXPLAIN` 截图）
7. 展示备份恢复：恢复后数据完整、关键行数一致
8.（加分）主从复制：从库只读查询、解释延迟与一致性

---

## 5. 落地建议（按工作量排序）

**半天内可完成**
- 补约束 + 补索引 + 准备 `EXPLAIN` 截图
- 做“订单状态流水表”并在业务更新处写入
- 做权限与只读账号演示

**1–2 天可完成**
- 事务并发控制（悲观锁/乐观锁二选一）
- 分区表（订单按月）
- 备份恢复演练与文档化

**2–3 天可完成（进阶展示）**
- 主从复制 + 读写分离（Docker/两实例）
- 伪分片拆表 + 统一查询
- 轻量报表/汇总表与定时刷新思路

